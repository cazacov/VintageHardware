/* 
 * Olivetti M24 / AT&T 6300 Keyboard Emulator
 * v.1.00
 * Copyirght (C) Valerio 2018
 * 
 * This emulator is for use with an Arduino Nano / Uno (Atmel ATmega328p)
 * to convert scan codes from an AT/PS/2 keyboard using scan code set 2
 * to scan codes that would be generated by the original keyboard
 * of an Olivetti M24 / AT&T PC 6300. Specifically, the keyboard being 
 * emulated is a either an 83-key "Keybaord 1" keyboard (default) or a 
 * 103-key, "Keyboard 2" type (or "deluxe" type) keyboard, both with
 * a US key layout. RightCTRL+1 or 2 switches between the two.
 * 
 * This software requires external hardware to pull down the DATA line of
 * the M24 keyboard interface, as well as the DATA and CLOCK lines of the 
 * PS/2 interface. All testing was done using a 74LS07 for this purpose, 
 * although other solutions could work (such as discrete transistors).
 * 
 * 
 * CREDITS:
 *  The code layout was partially inspired by (but does not use)
 *  https://github.com/techpaul/PS2KeyAdvanced
 *  (note: no external library is required to run this software)
 *  
 * DISCLAIMER: (don't skip this part)
 *  If you choose to use this software you do so at your own risk.
 *  Vintage hardware is often rare and irreplaceable so assess carefully
 *  whether you have the skills to correctly gauge the risks of using
 *  this software for your own purposes. Full details in the license 
 *  section below.
 * 
 * LICENSE:
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *  
 */

#include "Arduino.h"

// this file includes the mapping between scancodes (non-E0 type only)
#include "m24_keymap.h"

// *********************************************************
// ***********    Arduino I/O PIN DEFINITIONS    ***********
// *********************************************************

// Arduino pins corresponding to M24/AT keyboard interface lines
// Note the use a separate pin to modify the state of these lines

// AT/PS/2 lines
#define AT_DATA_RD 4
#define AT_CLOCK_RD 3
#define AT_DATA_WR 7
#define AT_CLOCK_WR 8

// M24 lines
#define M24KB_CLOCK 2
#define M24KB_DATA_WR 5
#define M24KB_DATA_RD 6

// Configuration pins
// JP2 is 13, JP3 is 11
// TODO: route JP2 to a different pin (12?) - 13 is not usable
#define DEBUG_PIN 11
#define TTY_PIN 12
bool serial_debug = false;
bool serial_tty = false;

// **********************************************
// ***********    BEGIN AT SECTION    ***********
// **********************************************

// M24 status variables: needed here as checked in the AT CLOCK ISR
#define M24_IDLE 0x00
#define M24_TX 0x01
#define M24_RX 0x02
#define M24_LOCK 0x04
volatile uint8_t m24_status = 0x00;

volatile uint8_t m24_keyb_type = 0x02;

// helper variables for send/receive
volatile uint8_t at_byte_received = 0x00;
volatile uint8_t at_bit_received = 0x00;
volatile uint8_t at_byte_to_send = 0x00;
volatile uint8_t at_bit_to_send = 0x00;
volatile uint8_t at_bitcount = 0;

#define AT_FLAG_BRK 0x01
#define AT_FLAG_E0 0x02
#define AT_FLAG_E1 0x04
#define AT_FLAG_RCTRL 0x08
#define AT_FLAG_PARITY 0x10
#define AT_FLAG_RX 0x20
#define AT_FLAG_TX 0x40
volatile uint8_t at_status = 0x00;

// special AT scan codes
#define AT_KEY_BAT 0xAA
#define AT_KEY_E0 0xE0
#define AT_KEY_E1 0xE1
#define AT_KEY_BRK 0xF0
#define AT_KEY_ACK 0xFA
#define AT_KEY_OVR 0xFC
#define AT_KEY_ERR 0xFF

#define AT_KEY_RCTRL 0x14

#define AT_DELAY 1000
#define AT_RESET_TIMEOUT 500
volatile uint32_t at_timestamp = 0;

bool at_keyboard_present = true;

// forward declarations
void at_process_byte();

// simple class implementing a ring buffer
#define RINGBUFFER_MAXSIZE 16
class ringBuffer
{
  private:
    volatile uint8_t data[RINGBUFFER_MAXSIZE];
    volatile uint8_t head;
    volatile uint8_t tail;
    volatile bool isfull;
  public:
    ringBuffer() : head(0), tail(0), isfull(false) {}

    void clear()
    {
      head = 0;
      tail = 0;
      isfull = false;
    }
    bool empty() const { return (head == tail) && !isfull; }
    bool full() const { return isfull; }
    bool add(uint8_t value) 
    {
      if(isfull)
        return false;
      noInterrupts();
      data[head] = value;
      head++;
      if(head == RINGBUFFER_MAXSIZE)
        head = 0;
      if(head == tail)
        isfull = true;
      interrupts();
      return true;
    }
    bool extract(uint8_t& value)
    {
      if(empty())
        return false;
      noInterrupts();
      value = data[tail];
      isfull = false;
      tail++;
      if(tail == RINGBUFFER_MAXSIZE)
        tail = 0;
      interrupts();
      return true;
    }
};

ringBuffer at_incoming;
ringBuffer at_incoming_special;
ringBuffer at_outgoing;

void disable_at_keyboard()
{
  digitalWrite(AT_CLOCK_WR, LOW); // disable AT keyboard

  // restore helper variables to initial state
  // so we are ready for next time
  at_byte_received = 0x00;
  at_status &= ~AT_FLAG_PARITY;
  at_status &= ~AT_FLAG_RX;
  at_bitcount = 0;
}

// initiate a host-to-keyboard cycle
// byte to be sent must already be in at_byte_to_send
// this routine WILL generate a CLOCK interrupt
void at_send_byte()
{
  if(at_keyboard_present)
  {
    at_status |= AT_FLAG_TX;
    digitalWrite(AT_CLOCK_WR, LOW);
    delayMicroseconds(60);
    digitalWrite(AT_DATA_WR, LOW);
    // release CLOCK line
    digitalWrite(AT_CLOCK_WR, HIGH);
  }
}

// interrupt service routine for AT CLOCK
void at_clk_isr()
{
  at_bit_received = digitalRead(AT_DATA_RD);

  if(m24_status & M24_TX || m24_status & M24_RX)
    return;
    
  switch( at_bitcount )
  {
  case 0:
    if(at_bit_received == 0x00) // start bit should be 0
    {
      // Start bit
      at_byte_received = 0x00;
      at_status &= ~AT_FLAG_PARITY;
      at_status |= AT_FLAG_RX;
      at_bitcount++;
    }
    else if(at_status & AT_FLAG_TX)
    {
      // we have something to send: prepare
      at_bit_to_send = at_byte_to_send & 0x01;
      if(at_bit_to_send)
        at_status |= AT_FLAG_PARITY;
      else
        at_status &= ~AT_FLAG_PARITY;
      at_bitcount++;
    }
    else if(serial_debug)
      Serial.println(F("AT Clock Error"));
    
    break;

  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
    if(at_status & AT_FLAG_RX)
    {
      // Data bits
      if(at_bit_received & 0x01)
      {
        at_byte_received |= 0x80; // OR in at MSB, will get shifted right later
        at_status ^= AT_FLAG_PARITY;
      }
      // prepare to receive next one
      if(at_bitcount < 8)
        at_byte_received >>= 1;
    }
    else if(at_status & AT_FLAG_TX)
    {
      digitalWrite(AT_DATA_WR, at_bit_to_send);
      if(at_bitcount < 8)
      {
        // prepare next one to send
        at_byte_to_send >>= 1;
        at_bit_to_send = at_byte_to_send & 0x01;
        if(at_bit_to_send)
          at_status ^= AT_FLAG_PARITY;
      }
    }
    at_bitcount++;
    break;
    
  case 9: 
    if(at_status & AT_FLAG_RX)
    {
      // Parity check
      if(at_bit_received & 0x01)
        at_status ^= AT_FLAG_PARITY;
      at_status ^= AT_FLAG_PARITY;
      // ODD parity: this flag should now be cleared if no parity error
    }
    else if(at_status & AT_FLAG_TX)
    {
      // Send ODD parity bit
      at_status ^= AT_FLAG_PARITY;
      digitalWrite(AT_DATA_WR, at_status & AT_FLAG_PARITY);
    }
    at_bitcount++;
    break;
    
  case 10: 
    // Stop bit lots - last one if in RX mode
    // should check stop bit == 1
    if(at_status & AT_FLAG_RX)
    {
      if(serial_debug)
      {
        if(at_status & AT_FLAG_PARITY)
          Serial.print("Parity error - ");
      
        Serial.print(F("AT: "));
        Serial.println(at_byte_received, HEX);
      }
  
      at_process_byte();
      at_bitcount = 0;
      at_status &= ~AT_FLAG_RX;
      at_timestamp = micros();
    }
    else if(at_status & AT_FLAG_TX)
    {
      // Send stop bit ie release DATA line
      digitalWrite(AT_DATA_WR, HIGH);
      at_bitcount++;  // !!! Extra bitcount step after this (ACK)
    }
    break;
  
  case 11:
    // ACK bit (TX only)
    if(at_status & AT_FLAG_TX)
    {
      if(at_bit_received & 0x01)
        if(serial_debug)
          Serial.println(F("AT TX: ACK Error"));

      at_bitcount = 0;
      at_status &= ~AT_FLAG_TX;
      at_timestamp = micros();
    }
    break;
    
  default:
    at_bitcount = 0;
    break;
  }
}

// convert single M24 Keyboard 1 scancodes to Keyboard 2 scancodes
void m24_convert_to_keyb2(uint8_t& scancode)
{
  const bool isbreak = (scancode & 0x80);
  
  scancode &= 0x7F; // convert to "make"
  
  if(scancode == M24_KC_OB)
    scancode = M24_KC_CB;
  else if(scancode == M24_KC_CB)
    scancode = M24_KC_TL;
  else if(scancode == M24_KC_TL)
    scancode = M24_KC_OB;
  else if(scancode > 0x53)
    scancode = M24_NOTFOUND;

  if(isbreak)
    scancode |= 0x80;
}

// convert to M24 scancodes
void at_process_byte()
{
  // set flags first
  if(at_byte_received > 0x7F && at_byte_received != 0x83) // 0x83 is F7 - special case!!
  {
    if(at_byte_received == AT_KEY_BRK)
      at_status |= AT_FLAG_BRK;
    else if(at_byte_received == AT_KEY_E0)
      at_status |= AT_FLAG_E0;
    else if(at_byte_received == AT_KEY_E1)
    {
      at_status |= AT_FLAG_E0;  // set both E0 and E1 so it takes two passes to clear E1
      at_status |= AT_FLAG_E1;
    }
    else
      at_incoming_special.add(at_byte_received);
  }
  else if(at_status & AT_FLAG_E1)
  {
    if(at_status & AT_FLAG_E0)
      at_status &= ~AT_FLAG_E0; // clear E0 at first pass
    else
      at_status &= ~AT_FLAG_E1; // clear E1 at second pass

    at_status &= ~AT_FLAG_BRK;
  }
  else // "real" byte
  {
    uint8_t at_byte_processed = M24_NOTFOUND;
    
    if(at_status & AT_FLAG_E0)  // handle E0-type first
    {
      at_status &= ~AT_FLAG_E0;

      switch(at_byte_received)
      {
        case AT_KEY_RCTRL:
          if(at_status & AT_FLAG_BRK)
            at_status &= ~AT_FLAG_RCTRL;
          else
            at_status |= AT_FLAG_RCTRL;
          break;

        case 0x4A:  // keypad division "/"
          at_byte_processed = M24_KC_DIV;
          break;
        case 0x5A:  // keypad enter
          at_byte_processed = M24_KC_KPE;
          break;
        case 0x6B:  // left arrow
          at_byte_processed = M24_KC_LF;
          break;
        case 0x6C:  // HOME key maps to M24 BREAK key
          at_byte_processed = M24_KC_BRK;
          break;
        case 0x70:  // INS key maps to M24 HELP key
          at_byte_processed = M24_KC_HLP;
          break;
        case 0x71:  // DEL key maps to M24 CLEAR key
          at_byte_processed = M24_KC_CLR;
          break;
        case 0x72:  // down arrow
          at_byte_processed = M24_KC_DN;
          break;
        case 0x74:  // right arrow
          at_byte_processed = M24_KC_RT;
          break;
        case 0x75:  // up arrow
          at_byte_processed = M24_KC_UP;
          break;
        case 0x7C:  // Print Screen key - also sends spurious E0 12, which is ignored
          at_byte_processed = M24_KC_PRT;
          break;
        
        default:
          break;
      }
    }
    else    // standard, not-E0-type case
    {
      if(at_status & AT_FLAG_RCTRL)
      {
        switch(at_byte_received)
        {
          case 0x16:  // RCTRL+1 - switch to keyboard ID byte 0x02 (83-Key, "Type 1")
            m24_keyb_type = 0x02;
            break;
          case 0x1E:  // RCTRL+2 - switch to keyboard ID byte 0x01 (102-Key, "Type 2" or "Deluxe")
            m24_keyb_type = 0x01;
            break;
          case 0x26:  // RCTRL+3 - switch to keyboard ID byte 0x03 ("DATEV" keyboard - not implemented)
            m24_keyb_type = 0x03;
            break;
          case 0x25:  // RCTRL+4 - switch to keyboard ID byte 0x04 ("84-Key" - not implemented)
            m24_keyb_type = 0x04;
            break;
          case 0x2E:  // RCTRL+5 - switch to keyboard ID byte 0x05
            m24_keyb_type = 0x05;
            break;
          case 0x36:  // RCTRL+6 - switch to keyboard ID byte 0x06
            m24_keyb_type = 0x06;
            break;
          
          case 0x70:  // use RCTRL+Keypad0 to mean "00" M24 key
            at_byte_processed = M24_KC_KP00;
            break;
       
        // todo: F13-F18 keys

          default:
            break;
        }
      }
      // F7 needs to be processed separately since it's the only non-E0 AT scancode above 0x7F
      else if(at_byte_received == 0x83)
        at_byte_processed = M24_KC_F7;
      else
        at_byte_processed = pgm_read_byte( &m24_keymap[at_byte_received] );
    }

    if(at_byte_processed != M24_NOTFOUND)
    {
      if(at_status & AT_FLAG_BRK)
        at_byte_processed |= 0x80;  // convert to Break code
      at_incoming.add(at_byte_processed);
    }

    at_status &= ~AT_FLAG_BRK;
  }

  return;
}

// ***********************************************
// ***********    BEGIN M24 SECTION    ***********
// ***********************************************

// helper variables for send/receive
volatile uint8_t m24_byte_to_send = 0x00;
volatile uint8_t m24_bit_to_send = 0x00;
volatile uint8_t m24_byte_received = 0x00;
volatile uint8_t m24_bit_received = 0x00;
volatile uint8_t m24_bitcount = 0;

ringBuffer m24_incoming;

volatile uint8_t m24_lock_status = 0x00;

#define M24_TIMEOUT 1500
volatile uint32_t m24_timestamp = 0x0;

#define M24_RESET_TIME 25000
volatile uint32_t m24_reset_timestamp = 0x0;
uint32_t m24_last_reset_timestamp = 0x0;
uint8_t m24_reset_counter = 0x0;
bool m24_blink_leds_on_reset = false;

void m24_timeout_cleanup()
{
  m24_status = M24_IDLE;
  m24_bitcount = 0;
  digitalWrite(M24KB_DATA_WR, HIGH);
  // re-enable AT keyboard
  digitalWrite(AT_CLOCK_WR, HIGH);
}

// interrupt service routine for M24 CLOCK
void m24_clk_isr()
{
  if(m24_bitcount == 0)
  {
    if(digitalRead(M24KB_DATA_RD) == LOW)
    {
      // set receive mode. TX status is cleared and may be lost!!
      m24_status |= M24_RX;
      m24_status &= ~M24_TX;
      m24_byte_received = 0x00;
      m24_bitcount++;
      disable_at_keyboard();
      m24_timestamp = micros();  // reset timeout timestamp
    }
    else if(m24_status & M24_TX)
    {
      // we have something to send - set KBDATA LOW
      digitalWrite(M24KB_DATA_WR, LOW);
      // prepare first bit to be sent
      m24_bit_to_send = m24_byte_to_send & 0x01;
      m24_bitcount++;
      disable_at_keyboard();
      m24_timestamp = micros();  // reset timeout timestamp
    }
  }
  else  // real clock pulses are being generated!
  {
    if(m24_status & M24_TX)
    {
      digitalWrite(M24KB_DATA_WR, m24_bit_to_send);
      if(m24_bitcount < 8)
      {
        // prepare next one to send
        m24_byte_to_send >>= 1;
        m24_bit_to_send = m24_byte_to_send & 0x01;
        m24_bitcount++;
      }
      else
      {
        // last bit has been sent
        // wait enough time for last clock pulse to finish, then restore KBDATA to high
        delayMicroseconds(100); 
        digitalWrite(M24KB_DATA_WR, HIGH);
        m24_bitcount = 0;
        m24_status &= ~M24_TX;  // end TX status
        m24_reset_counter = 0;
        // re-enable AT keyboard
        digitalWrite(AT_CLOCK_WR, HIGH);
      }
    }
    else if(m24_status & M24_RX)
    {
      m24_bit_received = digitalRead(M24KB_DATA_RD);
      // store it
      if(m24_bit_received & 0x01)
        m24_byte_received |= 0x80;  // set MSB (will get shifted right)
      if(m24_bitcount < 8)
      {
        // prepare to receive next one
        m24_byte_received >>= 1;
        m24_bitcount++;  
      }
      else
      {
        // last bit received and stored - clear RX status and flag that one byte has been received
        m24_status &= ~M24_RX;    // end RX status
        m24_bitcount = 0;
        m24_incoming.add(m24_byte_received);
        m24_reset_counter = 0;
        // re-enable AT keyboard
        digitalWrite(AT_CLOCK_WR, HIGH);
      }
    }
  }
  m24_reset_timestamp = micros(); // to check if we are in reset mode
}


// ****************************************
// ***********    SETUP HERE    ***********
// ****************************************

// blink L LED forever
void blinkforever()
{
  while(true)
  {
    digitalWrite(13, LOW);
    delay(250);
    digitalWrite(13, HIGH);
    delay(250);
  }
}

void setup() 
{
  // M24 pins
  pinMode(M24KB_CLOCK, INPUT);
  pinMode(M24KB_DATA_RD, INPUT);
  
  // LOW on this pin results in the DATA line 
  // being pulled LOW by external circuitry (eg 74LS07)
  digitalWrite(M24KB_DATA_WR, HIGH);
  pinMode(M24KB_DATA_WR, OUTPUT);
  
  // AT pins
  pinMode(AT_CLOCK_RD, INPUT);
  pinMode(AT_DATA_RD, INPUT);
  // LOW on this pin results in the DATA/CLOCK line 
  // being pulled LOW by external circuitry (eg 74LS07)
  digitalWrite(AT_DATA_WR, HIGH);
  pinMode(AT_DATA_WR, OUTPUT);
  digitalWrite(AT_CLOCK_WR, HIGH);
  pinMode(AT_CLOCK_WR, OUTPUT);
  
  // setup pins configured with internal pull-up resistor
  // "true" if pulled down to ground externally (ie if jumper is fitted)
  serial_debug = true;
  serial_tty = true;
  m24_blink_leds_on_reset = true;
  pinMode(DEBUG_PIN, INPUT_PULLUP);
  // pinMode(TTY_PIN, INPUT_PULLUP);
  delay(1);
  serial_debug = (digitalRead(DEBUG_PIN) == LOW);
  // serial_tty = (digitalRead(TTY_PIN) == LOW);
  
  // we use this (usually marked "L") as status LED
  pinMode(13, OUTPUT);
  // HIGH = LED on (solid) = init in progress
  digitalWrite(13, HIGH);
  
  if(serial_debug || serial_tty)
  {
    Serial.begin(115200);
    Serial.println(F("M24 Keyboard Emulator"));
  }
  
  // setup service to send/receive data for AT
  at_incoming.clear();
  at_incoming_special.clear();
  at_bitcount = 0;
  attachInterrupt(digitalPinToInterrupt(AT_CLOCK_RD), at_clk_isr, FALLING);
  
  // reset AT keyboard
  at_byte_to_send = 0xFF;
  at_send_byte();
  uint32_t at_reset_timestamp = millis();
  uint8_t at_reset_byte1 = 0x00;
  uint8_t at_reset_byte2 = 0x00;
  while( (millis() - at_reset_timestamp) < AT_RESET_TIMEOUT && !at_incoming_special.extract(at_reset_byte1) ) {}
  while( (millis() - at_reset_timestamp) < AT_RESET_TIMEOUT && !at_incoming_special.extract(at_reset_byte2) ) {}

  at_keyboard_present = (at_reset_byte1 == AT_KEY_ACK && at_reset_byte2 == AT_KEY_BAT);
  if(at_keyboard_present)
  {
    if(serial_debug)
      Serial.println(F("AT keyboard reset successful"));
  }
  else
  {
    detachInterrupt(digitalPinToInterrupt(AT_CLOCK_RD));
    at_incoming.clear();
    //at_incoming_special.clear();
    at_bitcount = 0;
    at_status = 0x00;

    if(serial_debug)
    {
      Serial.print(F("AT keyboard reset error - received: "));
      Serial.print(at_reset_byte1, HEX);
      Serial.print(F(" "));
      Serial.println(at_reset_byte2, HEX);
    }
  
    if(!serial_tty)
      blinkforever();
  }
  
  // setup timeout timestamp and init status
  m24_timeout_cleanup();
  m24_incoming.clear();
  m24_keyb_type = 0x02; 
  
  // setup service to send/receive data for M24
  attachInterrupt(digitalPinToInterrupt(M24KB_CLOCK), m24_clk_isr, FALLING);
 
  // end of init: switch off L LED
  digitalWrite(13, LOW);
  if(serial_debug)
    Serial.println(F("Initialization complete"));

}

// ***************************************
// ***********    LOOP HERE    ***********
// ***************************************

void loop()
{
  //uint32_t timestampnow = micros();
  
  if( !(m24_status & M24_RX)    &&
      !(m24_status & M24_TX)    &&
      !(at_status & AT_FLAG_RX) &&
      !(at_status & AT_FLAG_TX) &&
      (micros() - at_timestamp) > AT_DELAY )
  {
    uint8_t at_byte_incoming = 0x00;
    uint8_t m24_byte_incoming = 0x00;
    uint8_t at_byte_outgoing = 0x00;

    // first check if a byte has arrived from AT keyboard
    // that needs to be sent over to M24 (already converted)
    if(at_incoming.extract(at_byte_incoming))
    {
      if(m24_keyb_type == 0x01) // if Keyboard 2, convert scancodes and eliminate illegal ones
        m24_convert_to_keyb2(at_byte_incoming);
        
      if(at_byte_incoming != M24_NOTFOUND)
      {
        if(serial_debug)
        {
          Serial.print(F(" M24: "));
          Serial.println(at_byte_incoming, HEX);
        }
  
        // set TX status
        m24_byte_to_send = at_byte_incoming;
        m24_status |= M24_TX;
      }
    }
    // second, check if a byte has been received from M24
    // these have not been processed so need to be parsed here
    else if(m24_incoming.extract(m24_byte_incoming))
    {
      if(serial_debug)
      {
        Serial.print(F("Received from M24: "));
        Serial.println(m24_byte_incoming, HEX);
      }

      // check if we had already received a code
      // indicating a change in LOCK status
      if(m24_status & M24_LOCK)
      {
        switch(m24_byte_incoming)
        {
        case 0x01:
          m24_lock_status &= ~0x04;   // CAPS off
          break;
        case 0x02:
          m24_lock_status &= ~0x02;   // NUM off
          break;
        case 0x04:
          m24_lock_status &= ~0x01;   // SCROLL off
          break;
        case 0x81:
          m24_lock_status |= 0x04;   // CAPS on
          break;
        case 0x82:
          m24_lock_status |= 0x02;   // NUM on
          break;
        case 0x84:
          m24_lock_status |= 0x01;   // SCROLL on
          break;
        default:
          if(serial_debug)
            Serial.println(F("Unknown LOCK code from M24"));
          break;
        }

        if(serial_debug)
        {
          Serial.print(F("Sending LED status byte: "));
          Serial.println(m24_lock_status, HEX);
        }
        at_outgoing.add(0xED);
        at_outgoing.add(m24_lock_status);    // may not have changed
        m24_status &= ~M24_LOCK;
      }
      else if(m24_byte_incoming == 0x13)  // LOCK case: set flag
        m24_status |= M24_LOCK;
      else if(m24_byte_incoming == 0x10)  // not sure what the right response is after 0xAA
      {
        at_incoming.add(0xAA);  // reset acknowledge
        at_incoming.add(0xFF);  // reset acknowledge
        at_incoming.add(m24_keyb_type);  // keyboard ID byte
      }
    }
    // third, check if we have a byte in the queue to be sent to the AT keyboard
    else if(at_outgoing.extract(at_byte_outgoing))
    {
      at_byte_to_send = at_byte_outgoing;
      at_send_byte();
    }
    // fourth, display any special codes coming from AT keyboard (if in debug mode)
    else if(at_incoming_special.extract(at_byte_incoming))
    {
      if(serial_debug)
      {
        Serial.print(F("AT (special): "));
        Serial.println(at_byte_incoming, HEX);
      }
    }
    // last, check if we are in tty mode and a byte has been received from the serial interface
    else if(serial_tty)
    {
      if(Serial.available() > 0)
      {
        uint8_t ttybyte = Serial.read();

        if(serial_debug)
        {
          Serial.print(F("Serial (TTY): "));
          Serial.println(ttybyte, HEX);
        }
        if(ttybyte < 0x80)
        {
          uint8_t m24_byte_from_serial = pgm_read_byte( &m24_ascii_keymap[ttybyte] );
          if(m24_byte_from_serial != M24_NOTFOUND)
          {
            if(m24_byte_from_serial & 0x80) // MSB indicates a shift is needed
              at_incoming.add(M24_KC_LSHF);  // add left-shift (make)
            at_incoming.add(m24_byte_from_serial & 0x7F);
            at_incoming.add(m24_byte_from_serial | 0x80); // (break)
            if(m24_byte_from_serial & 0x80) // MSB indicates a shift is needed
              at_incoming.add(M24_KC_LSHF | 0x80);  // add left-shift (break)
          }
        }
      }
    }
  }

  // timeout test so we do not get stuck waiting for an M24 clock pulse
  // Esp. needed after CRTL-ALT-DEL
  if( ((m24_status & M24_RX) || (m24_status & M24_TX)) 
      && m24_bitcount > 0
      && (micros() - m24_timestamp) > M24_TIMEOUT )
  {
    m24_timeout_cleanup();
    if(serial_debug)
      Serial.println(F("M24 Timeout"));
  }

  // if M24 clock is low for longer than M24_RESET_TIME, blink all LEDs
  noInterrupts();
  const uint32_t m24_reset_timestamp_here = m24_reset_timestamp;
  interrupts();
  
  if( (m24_reset_timestamp_here != m24_last_reset_timestamp)    &&
      ((micros() - m24_reset_timestamp_here) > M24_RESET_TIME)  )
  {
    m24_last_reset_timestamp = m24_reset_timestamp_here;
    if(digitalRead(M24KB_CLOCK) == LOW)
    {
      m24_reset_counter++;
      if(serial_debug)
      {
        Serial.print(F(" RST:"));
        Serial.print(m24_reset_counter);
      }
      
      // blink AT keyboard LEDs after 4 reset pulses
      if( at_keyboard_present     && 
          m24_blink_leds_on_reset && 
          m24_reset_counter > 4   )
      {
        at_byte_to_send = 0xED;
        at_send_byte();
        delay(3);
        at_byte_to_send = 0x07;  // all LEDs on
        at_send_byte();
        delayMicroseconds(M24_RESET_TIME);
        at_byte_to_send = 0xED;
        at_send_byte();
        delay(3);
        at_byte_to_send = 0x00;  // all LEDs off
        at_send_byte();
        
        m24_lock_status = 0x0;
      }
    }
  }
}
